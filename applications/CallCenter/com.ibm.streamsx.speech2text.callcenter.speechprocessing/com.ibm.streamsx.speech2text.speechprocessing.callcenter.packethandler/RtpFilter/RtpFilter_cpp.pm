
package RtpFilter_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*******************************************************************************', "\n";
   print ' * Copyright (C) 2016, International Business Machines Corporation', "\n";
   print ' * All Rights Reserved', "\n";
   print ' *******************************************************************************/', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{ ', "\n";
   print ' xxx = 0;', "\n";
   print '    // Initialization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '    /*', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '    */', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '    /*', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '          // do work ...', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{   ', "\n";
   print '        xxx = xxx + 1; ', "\n";
   print '	IPort0Type const & ituple = static_cast<IPort0Type const&>(tuple);', "\n";
   print '	int dstPort = ituple.get_dstPort();', "\n";
   print '  const unsigned char *packet = ituple.get_netflowMessage().getData();', "\n";
   print '  int payloadLength = ituple.get_payloadLength(); ', "\n";
   print "\n";
   print "\n";
   print '/*', "\n";
   print '    if ( ituple.get_ipSrc_addr().compare("10.191.98.158") )  ', "\n";
   print '       return; ', "\n";
   print '*/', "\n";
   print "\n";
   print '/* ', "\n";
   print '     if (! ( ituple.get_ipSrc_addr().compare("10.170.147.119") == 0)  )  ', "\n";
   print '       return; ', "\n";
   print '*/ ', "\n";
   print "\n";
   print '    int protocol = ituple.get_protocol(); ', "\n";
   print '    if ( protocol != 17 ) ', "\n";
   print '       return; ', "\n";
   print '      ', "\n";
   print '  //fprintf(stderr, "payload length: %d\\n", payloadLength);', "\n";
   print '    ', "\n";
   print '  if (payloadLength < RTP_MIN_SIZE) // Minimum size according to RFC', "\n";
   print '  	return;', "\n";
   print '       ', "\n";
   print ' // if ((dstPort & 1) == 1) // According to the specification an RTP port should be even', "\n";
   print ' // 	return;', "\n";
   print '   	', "\n";
   print '//  if (dstPort >= 32768) // RTP port when transmitting the audio should be in the range [0, 32767]', "\n";
   print '  //	return;	', "\n";
   print '    	', "\n";
   print '	int rtpVersion = RTP_VERSION(*packet);', "\n";
   print '	int payloadType = RTP_PAYLOAD_TYPE(*(packet+1));', "\n";
   print "\n";
   print '//	fprintf(stderr, "RTP_VERSION: %d\\n", rtpVersion);', "\n";
   print '//	fprintf(stderr, "RTP_PAYLOAD_TYPE: %d\\n", payloadType);', "\n";
   print "\n";
   print ' //  if (rtpVersion == RTP_CURRENT_VERSION && payloadType == G711U && payloadLength >= PAYLOAD_LENGTH) {  ', "\n";
   print '   if (rtpVersion == RTP_CURRENT_VERSION && payloadType == G711U ) {  ', "\n";
   print "\n";
   print '  // std::cout << "xxx  " << xxx << std::endl; ', "\n";
   print '  //  std::cout <<  "destination port " << dstPort << std::endl; ', "\n";
   print '  ', "\n";
   print '        // std::cout << "payload length " << payloadLength << std::endl;', "\n";
   print "\n";
   print '    	OPort0Type otuple;', "\n";
   print '    	otuple.set_dstPort(dstPort);', "\n";
   print '    	otuple.set_ipSrc_addr(ituple.get_ipSrc_addr()); ', "\n";
   print '        otuple.set_captureSeconds(ituple.get_captureSeconds() ); ', "\n";
   print "\n";
   print '    	otuple.set_netflowMessage(ituple.get_netflowMessage());', "\n";
   print "\n";
   print '    	otuple.set_payloadLength(payloadLength);', "\n";
   print "\n";
   print '    	submit(otuple, 0); // submit to output port 0', "\n";
   print '}       ', "\n";
   print '    ', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
