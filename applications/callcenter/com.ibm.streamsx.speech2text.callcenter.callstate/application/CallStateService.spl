namespace application ;

use com.ibm.streamsx.json::* ;
use com.ibm.streamsx.store.distributed::*;
use com.ibm.streamsx.topology.topic::*; 

// To make this type adaptable, we want to force the attributes that we require,
// but let the actual event be a JSON string
type CTIEventGeneralized = 
	tuple<rstring commonCallId, rstring eventAction, int64 eventTime, rstring eventJson>;  

//type CTIEventDpsReady = 
//	tuple<rstring key, rstring commonCallId, rstring eventAction, rstring eventJson>;  

type CallStateAndEventHistoryValue = 
	tuple<rstring state, list<rstring> callStateJourney, list<rstring> callActionJourney, list<rstring> eventsJson, list<int64> eventTimes>;

type CTIEventWithCallStateAndEventHistory = 
	tuple<CTIEventGeneralized>, tuple<CallStateAndEventHistoryValue value> ;

composite CallStateService
{ 
	param
		expression<float64> $aggregateTime : 500.0; 
		expression<float64> $partitionTime : 100.0;
	graph

		stream<CTIEventGeneralized> TranslatedCtiEvents = TranslateCTIFeed()
		{
		}
		
		/*
		 * Keep mapping of action to state out here because it is effectively stateless
		 */
		
		@threading(model=manual)
		stream<CTIEventWithCallStateAndEventHistory> RedisPutResults
			= ReadModifyUpdate(TranslatedCtiEvents)
			{
				param
					ttl : (uint32) $aggregateTime; 
			}

		
		() as TestPrinter = Custom(UpdatedCallState as In)
		{
			logic 
				onTuple In: 
				{
//					printStringLn("FinalTuple: " + (rstring) In);
				}
		}
		
		stream<rstring commonCallId, rstring state, list<rstring> callStateJourney, list<rstring> callActionJourney, list<rstring> eventsJson, list<int64> eventTimes>
			UpdatedCallState = Functor(RedisPutResults){
				output UpdatedCallState : 
					state = value.state, 
					callStateJourney = value.callStateJourney,
					callActionJourney = value.callActionJourney, 
					eventsJson = value.eventsJson,
					eventTimes = value.eventTimes; 
			}
		
//		() as CallStatePublisher = Publish(UpdatedCallState)
//		{
//			param
//				topic : "callcenter/callStateChanges"; 
//		}


		stream<rstring commonCallId, rstring state, list<rstring> callStateJourney, list<rstring> callActionJourney, list<rstring> eventsJson, list<int64> eventTimes>
			WakeUpTuples = Beacon()
		{
			param
				period : 5.0; 
			output WakeUpTuples: commonCallId = "flushTuple", callStateJourney = ["flushTuple"]; 
		}
		/*
		 * Aggregate to only get the final values from each call (will include journey)
		 */
		stream<rstring commonCallId, rstring state, list<rstring> callStateJourney,  list<rstring> callActionJourney, list<rstring> eventsJson, list<int64> eventTimes>
			CallSummaries = Aggregate(UpdatedCallState, WakeUpTuples)
		{
			window UpdatedCallState : tumbling, time(1000000000.0), partitioned, partitionAge((float64) $aggregateTime) ;
			param
				partitionBy : commonCallId;
				aggregateEvictedPartitions : true;  
				
			output CallSummaries : 
				commonCallId = Last(commonCallId)
				, state = Last(state)
				, callStateJourney = Last(callStateJourney)
				, callActionJourney = Last(callActionJourney)
				, eventsJson = Last(eventsJson)
				, eventTimes = Last(eventTimes); 
		}
		
		() as SummaryPrinter = FileSink(CallSummaries as In)
		{
//			logic 
//				onTuple In: 
//				{
////					printStringLn("SummaryTuple: " + (rstring) In);
//				}
//			config
//				placement : partitionIsolation; 
			param
				file : "callSummaries.csv"; 
				flush : 1u; 
		}
		
		stream<rstring commonCallId, rstring callStateJourney, rstring callActionJourney, int64 callDuration>
			FlattenedCallSummaries = Functor(CallSummaries)
		{
			output FlattenedCallSummaries : 
				callStateJourney = (rstring) callStateJourney,
				callActionJourney = (rstring) callActionJourney,
				callDuration = eventTimes[size(eventTimes) - 1] - eventTimes[0]; 
		}
		
		
		stream<rstring commonCallId, rstring callStateJourney, rstring callActionJourney, int64 callDuration>
			WakeUpTuples2 = Beacon()
		{
			param
				period : 5.0; 
			output WakeUpTuples2: commonCallId = "flushTuple", callStateJourney = "flushTuple", callActionJourney = "flushTuple"; 
		}
		
		/*
		 * Aggregate to only get the final values from each call (will include journey)
		 */
		stream<rstring callStateJourney, int32 count, int64 avgCallDuration>
			CallTypeCounts = Aggregate(FlattenedCallSummaries, WakeUpTuples2)
		{
			window FlattenedCallSummaries  
			: tumbling, time(10000000), partitioned,
					partitionAge((float64) $partitionTime) ;
			param
				partitionBy : callStateJourney; 
				aggregateEvictedPartitions : true; 
			output CallTypeCounts : 
				callStateJourney = Any(callStateJourney)
				, count = Count(), avgCallDuration = Average(callDuration);
		}
		
//		stream<rstring callStateJourney, int32 count, int64 avgCallDuration>
//			SortedCallTypeCounts = Sort(CallTypeCounts)
//		{
//			window CallTypeCounts  
//			: tumbling, time($sortTime);
//			param
//				sortBy : count; 
//				order : descending; 
//		}
		
		() as StatPrinter = FileSink(CallTypeCounts as In)
		{
//			logic 
//				onTuple In: 
//				{
//					printStringLn((rstring) In);
//				}
//			config
//				placement : partitionIsolation; 
			param
				file : "callTypeCounts.csv"; 
				flush : 1u; 
		}
		
		/*
		 * Aggregate to only get the final values from each call (will include journey)
		 */
		stream<rstring callActionJourney, int32 count, int64 avgCallDuration>
			CallActionTypeCounts = Aggregate(FlattenedCallSummaries, WakeUpTuples2)
		{
			window FlattenedCallSummaries  
			: tumbling, time(10000000), partitioned,
					partitionAge((float64) $partitionTime) ;
			param
				partitionBy : callActionJourney; 
				aggregateEvictedPartitions : true; 
			output CallActionTypeCounts : 
				callActionJourney = Any(callActionJourney)
				, count = Count(), avgCallDuration = Average(callDuration);
		}
		
//		stream<rstring callActionJourney, int32 count, int64 avgCallDuration>
//			SortedCallActionTypeCounts = Sort(CallActionTypeCounts)
//		{
//			window CallActionTypeCounts  
//			: tumbling, time($sortTime);
//			param
//				sortBy : count; 
//				order : descending; 
//		}
		
		() as StatActionPrinter = FileSink(CallActionTypeCounts as In)
		{
//			logic 
//				onTuple In: 
//				{
//					printStringLn((rstring) In);
//				}
//			config
//				placement : partitionIsolation; 
			param
				file : "callActionTypeCounts.csv"; 
				flush : 1u; 
		}
}

stateful boolean initializeMetric(rstring name, rstring desc, int64 val)
{
	createCustomMetric(name, desc, Sys.Counter, val); 
	return true; 
}

composite ReadModifyUpdate(input In; output Out)
{
	param
		expression<rstring> $NO_CHANGE : "NO-STATE-CHANGE";
		expression<rstring> $IGNORE_ACTION : "IGNORE-ACTION";
		expression<uint32> $ttl; 
	graph
		stream<CTIEventWithCallStateAndEventHistory> EventsWithHistory 
			= DpsGetTTLWithReconnect(In)
		{
			param
				keyEncoded : false;
				valueEncoded : false; 
				keyAttribute : commonCallId; 
				outputType : CTIEventWithCallStateAndEventHistory; 
		}
		
		stream<CTIEventWithCallStateAndEventHistory> UpdatedCallStateEvents 
			= Custom(EventsWithHistory as events)
		{
			logic
				state : 
				{
					map<rstring,rstring> actionToStateMap = 
						{
							"CALLESTABLISHED" : "2-PARTY_ON_LINE",
							"RTPSTARTED" : $NO_CHANGE, 
							"RTPSTOPPED" : $NO_CHANGE,
							"HOLD" : "ON_HOLD", 
							"RETRIEVE" : "2-PARTY_ON_LINE",
							"CALL_TRANSFERRED" : "CALL_TRANSFERRED", 
							"CALL_CONFERENCED" : "CALL_ON_CONFERENCE", 
							"CALLFAILED" : "COMPLETE", 
							"RELEASE" : "COMPLETE"
						}; 
					rstring numUnrecognizedActionsMetricName = "numUnrecognizedActions"; 
					boolean initMetric = initializeMetric(numUnrecognizedActionsMetricName, 
						"Number of unrecognized actions that couldn't be mapped to a state change.", 
						0l); 
					mutable int64 numUnrecognizedActions = 0; 
				}
				onTuple events : 
				{
					// Check if we find the call in the DB
					// If it's a new call, everything is already null
					mutable CTIEventWithCallStateAndEventHistory outTuple = {}; 
					assignFrom(outTuple, events); 
					
					// update state
					if (has(actionToStateMap, events.eventAction))
					{
						if (actionToStateMap[events.eventAction] != $NO_CHANGE){
							outTuple.value.state = actionToStateMap[events.eventAction];
							appendM(outTuple.value.callStateJourney, outTuple.value.state); 
						}
						
						appendM(outTuple.value.eventsJson, events.eventJson); 
						appendM(outTuple.value.callActionJourney, events.eventAction);
						appendM(outTuple.value.eventTimes, events.eventTime);
						// Only submit after recognized actions
						submit(outTuple, UpdatedCallStateEvents);
					} else {
						numUnrecognizedActions++; 
						setCustomMetricValue(numUnrecognizedActionsMetricName,numUnrecognizedActions);
						appTrc(Trace.error,"Don't have a set actionToState mapping for action: " + events.eventAction);
					}
					
					
					

//					printStringLn("InputTuple: " + (rstring) events); 
//					printStringLn("OutTuple: " + (rstring) outTuple);
					
					
				}
		}
		
		stream<tuple<uint32 ttl>, tuple<CTIEventWithCallStateAndEventHistory>> PerparedForDpsEvents
			= Functor(UpdatedCallStateEvents)
		{
			output PerparedForDpsEvents : ttl = $ttl, value = UpdatedCallStateEvents.value; 
		} 
		
		stream<CTIEventWithCallStateAndEventHistory> Out 
			= DpsPutTTLWithReconnect(PerparedForDpsEvents)
		{
			param
				keyEncoded : false;
				valueEncoded : false; 
				keyAttribute : commonCallId; 
				valueAttribute : value; 
				ttlAttribute : ttl; 
				outputType : CTIEventWithCallStateAndEventHistory; 
		}
	config
		placement : partitionColocation("readModifyUpdate"); 
}

