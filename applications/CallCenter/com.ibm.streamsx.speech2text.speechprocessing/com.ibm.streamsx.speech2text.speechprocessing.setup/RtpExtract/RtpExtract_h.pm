
package RtpExtract_h;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print "\n";
   print '// Rtp', "\n";
   print '/* Type sizes */', "\n";
   print 'typedef int int32;', "\n";
   print 'typedef short int int16;', "\n";
   print 'typedef signed char int8;', "\n";
   print "\n";
   print 'typedef unsigned int u_int32;', "\n";
   print 'typedef unsigned short int u_int16;', "\n";
   print 'typedef unsigned char u_int8;', "\n";
   print "\n";
   print '#define BITFIELD(field, mask, shift) \\', "\n";
   print '   (((field) & (mask)) >> (shift))', "\n";
   print "\n";
   print '/* Protocol version */', "\n";
   print '#define RTP_VERSION(hdr) BITFIELD((hdr).flags, 0xC0, 6)', "\n";
   print '#define SET_RTP_VERSION(hdr, val) SET_BITFIELD((hdr).flags, (val), 0xC0, 6)', "\n";
   print "\n";
   print '/* Padding flag */', "\n";
   print '#define RTP_P(hdr) BITFIELD((hdr).flags, 0x20, 5)', "\n";
   print '#define SET_RTP_P(hdr, val) SET_BITFIELD((hdr).flags, (val), 0x20, 5)', "\n";
   print "\n";
   print '/* Extension flag */', "\n";
   print '#define RTP_X(hdr) BITFIELD((hdr).flags, 0x10, 4)', "\n";
   print '#define SET_RTP_X(hdr, val) SET_BITFIELD((hdr).flags, (val), 0x10, 4)', "\n";
   print "\n";
   print '/* CSRC Count */', "\n";
   print '#define RTP_CC(hdr) BITFIELD((hdr).flags, 0x0F, 0)', "\n";
   print '#define SET_RTP_CC(hdr, val) SET_BITFIELD((hdr).flags, (val), 0x0F, 0)', "\n";
   print "\n";
   print '/* Marker bit */', "\n";
   print '#define RTP_M(hdr) BITFIELD((hdr).mpt, 0x80, 7)', "\n";
   print '#define SET_RTP_M(hdr, val) SET_BITFIELD((hdr).mpt, (val), 0x80, 7)', "\n";
   print "\n";
   print '/* Marker bit */', "\n";
   print '#define RTP_PT(hdr) BITFIELD((hdr).mpt, 0x7F, 0)', "\n";
   print '#define SET_RTP_PT(hdr, val) SET_BITFIELD((hdr).mpt, (val), 0x7F, 0)', "\n";
   print "\n";
   print 'typedef struct { /* RTP Header Extension */', "\n";
   print '	u_int16 etype; /* extension type */', "\n";
   print '	u_int16 elen; /* extension length */', "\n";
   print '	char epayload[1]; /* extension payload */', "\n";
   print '} rtp_hdr_ext;', "\n";
   print "\n";
   print 'typedef struct {', "\n";
   print '	u_int8 flags; /* Protocol version, padding flag, extension flag,', "\n";
   print '	 and CSRC count */', "\n";
   print '	u_int8 mpt; /* marker bit and payload type */', "\n";
   print '	u_int16 seq; /* sequence number */', "\n";
   print '	u_int32 ts; /* timestamp */', "\n";
   print '	u_int32 ssrc; /* synchronization source */', "\n";
   print '	u_int32 csrc[1]; /* CSRC list */', "\n";
   print '} rtp_hdr_t;', "\n";
   print "\n";
   print 'typedef struct {', "\n";
   print '	rtp_hdr_t *RTP_header;', "\n";
   print '	rtp_hdr_ext *RTP_extension;', "\n";
   print '	unsigned char *payload; /* payload portion of RTP packet */', "\n";
   print '	long payload_len; /* The length of the payload */', "\n";
   print '} rtp_packet;', "\n";
   print "\n";
   print "\n";
   print '#define AUDIO_INBUF_SIZE 100', "\n";
   print '#define MAX_SAMPLE_COUNT_IN_ONE_PACKET 300', "\n";
   print "\n";
   SPL::CodeGen::headerPrologue($model);
   print "\n";
   print "\n";
   print 'class MY_OPERATOR : public MY_BASE_OPERATOR ', "\n";
   print '{', "\n";
   print 'public:', "\n";
   print '  // Constructor', "\n";
   print '  MY_OPERATOR();', "\n";
   print "\n";
   print '  // Destructor', "\n";
   print '  virtual ~MY_OPERATOR(); ', "\n";
   print "\n";
   print '  // Notify port readiness', "\n";
   print '  void allPortsReady(); ', "\n";
   print "\n";
   print '  // Notify pending shutdown', "\n";
   print '  void prepareToShutdown(); ', "\n";
   print "\n";
   print '  // Processing for source and threaded operators   ', "\n";
   print '  void process(uint32_t idx);', "\n";
   print '    ', "\n";
   print '  // Tuple processing for mutating ports ', "\n";
   print '  void process(Tuple & tuple, uint32_t port);', "\n";
   print '    ', "\n";
   print '  // Tuple processing for non-mutating ports', "\n";
   print '  void process(Tuple const & tuple, uint32_t port);', "\n";
   print "\n";
   print '  // Punctuation processing', "\n";
   print '  void process(Punctuation const & punct, uint32_t port);', "\n";
   print 'private:', "\n";
   print '  // Members', "\n";
   print '  ', "\n";
   print '  // Other', "\n";
   print '  int utteranceNumber;', "\n";
   print '  float samples_data[MAX_SAMPLE_COUNT_IN_ONE_PACKET];', "\n";
   print '}; ', "\n";
   print "\n";
   SPL::CodeGen::headerEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
