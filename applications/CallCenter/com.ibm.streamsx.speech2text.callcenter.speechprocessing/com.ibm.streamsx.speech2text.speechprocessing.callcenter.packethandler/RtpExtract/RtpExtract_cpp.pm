
package RtpExtract_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print ' ', "\n";
   print '#include<iostream>', "\n";
   print '#include<sstream> ', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{	', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '    ', "\n";
   print '    //free(samples_data);    ', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '    /*', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '    */', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '    /*', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '          // do work ...', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print 'rtp_packet RTPGetRTPPacket(const unsigned char *rtppacket, long pktlen) {', "\n";
   print '	rtp_packet the_packet;', "\n";
   print "\n";
   print '	/* If packet is encrypted, then the extra 32-bit header used', "\n";
   print '	 for encryption should have already been stripped off */', "\n";
   print '	the_packet.RTP_header = (rtp_hdr_t*) rtppacket;', "\n";
   print '	the_packet.RTP_header->seq = __bswap_16(the_packet.RTP_header->seq);', "\n";
   print '	the_packet.RTP_header->ts = __bswap_32(the_packet.RTP_header->ts);', "\n";
   print '	the_packet.RTP_header->ssrc = __bswap_32(the_packet.RTP_header->ssrc);', "\n";
   print "\n";
   print "\n";
   print '	if (RTP_X(*the_packet.RTP_header) == 1) { /* Is there an extension? */ ', "\n";
   print '   ', "\n";
   print '            std::cout << "extension" << std::endl; ', "\n";
   print "\n";
   print '		/* if so, then set up RTP_extension field. */', "\n";
   print "\n";
   print '		the_packet.RTP_extension = (rtp_hdr_ext*) ((char*) rtppacket', "\n";
   print '				+ sizeof(rtp_hdr_t) + (RTP_CC(*the_packet.RTP_header) - 1) * 4);', "\n";
   print "\n";
   print '		/* Note that if the packet has not yet been converted to host-byte-', "\n";
   print '		 ordering, then the extension length will be wrong, and so', "\n";
   print '		 the packet payload will point to the wrong place. */', "\n";
   print "\n";
   print '		the_packet.payload = ((unsigned char*) the_packet.RTP_extension', "\n";
   print '				+ (the_packet.RTP_extension->elen + 1) * 4);', "\n";
   print '	}', "\n";
   print "\n";
   print '	/* Otherwise, set extension field to NULL */', "\n";
   print '	else {', "\n";
   print '		the_packet.RTP_extension = NULL;', "\n";
   print '		the_packet.payload = ((unsigned char*) rtppacket + sizeof(rtp_hdr_t)', "\n";
   print '				+ (RTP_CC(*the_packet.RTP_header) - 1) * 4);', "\n";
   print '	}', "\n";
   print '	the_packet.payload_len = pktlen + (long) (rtppacket - the_packet.payload);', "\n";
   print "\n";
   print "\n";
   print '	if (RTP_P(*the_packet.RTP_header) == 1) {', "\n";
   print '	', "\n";
   print '            std::cout << "padding" << std::endl;  ', "\n";
   print "\n";
   print '	/* There is padding on this packet.  The # of bytes of padding', "\n";
   print '		 (stored in the last byte of the packet = where we currently', "\n";
   print '		 point to as the last byte in the payload) must be subtracted', "\n";
   print '		 from our current payload estimate. */', "\n";
   print '   ', "\n";
   print '                // jms this is gotta be wron', "\n";
   print '		// the_packet.payload_len -=', "\n";
   print '				(int) the_packet.payload[the_packet.payload_len - 1];', "\n";
   print '	}', "\n";
   print "\n";
   print '	return the_packet;', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    IPort0Type const & ituple = static_cast<IPort0Type const&>(tuple);', "\n";
   print '	  int dstPort = ituple.get_dstPort();', "\n";
   print '    const unsigned char *packet = ituple.get_netflowMessage().getData();', "\n";
   print '    int payloadLength = ituple.get_payloadLength();', "\n";
   print '   ', "\n";
   print '    // Extract RTP payload', "\n";
   print '    rtp_packet the_packet = RTPGetRTPPacket(packet, payloadLength);', "\n";
   print '   // fprintf(stderr, "%s RTP packet decoded, the payload length: %ld\\n", the_packet.payload, the_packet.payload_len);', "\n";
   print "\n";
   print "\n";
   print '/*', "\n";
   print '    if ( (  the_packet.payload_len > 0 ) &', "\n";
   print '       ( the_packet.payload_len > 2000 ) ) ', "\n";
   print '    {', "\n";
   print '*/ ', "\n";
   print ' ', "\n";
   print '    OPort0Type otuple; ', "\n";
   print "\n";
   print "\n";
   print '    otuple.set_ssrc(the_packet.RTP_header->ssrc); ', "\n";
   print '    otuple.set_ts(the_packet.RTP_header->ts); ', "\n";
   print '    otuple.set_seq(the_packet.RTP_header->seq); ', "\n";
   print '    otuple.set_ipSrc_addr(ituple.get_ipSrc_addr() ); ', "\n";
   print '    otuple.set_captureSeconds(ituple.get_captureSeconds() ); ', "\n";
   print "\n";
   print "\n";
   print '    otuple.set_payloadLength(the_packet.payload_len);', "\n";
   print '    // jms i dont get this ', "\n";
   print '   // otuple.set_payload(blob(the_packet.payload, the_packet.payload_len*sizeof(float)));', "\n";
   print '    otuple.set_payload(blob(the_packet.payload, the_packet.payload_len)); ', "\n";
   print '    submit(otuple, 0); // submit to output port 0        	    ', "\n";
   print '   ', "\n";
   print '  /*  } */ ', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
